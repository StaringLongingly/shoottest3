use std::ops::RangeInclusive;

const WINDOW_SIZE: (usize, usize) = (128, 32);

struct Line {
    point1: (usize, usize),
    point2: (usize, usize),
}

fn main() {
    let mut top_down = &mut [["."; WINDOW_SIZE.0]; WINDOW_SIZE.1];
    insert_to_array(top_down, 50, 20, "0");

    let line1 = Line {
        point1: (0, 0),
        point2: (10, 40),
    };

    overlay_line(&mut top_down, line1);

    render(&top_down);
}

fn overlay_line(array: &mut [[&str; WINDOW_SIZE.0]; WINDOW_SIZE.1], line: Line) {
    fn absolute_range(line: &Line) -> RangeInclusive<usize> {
        if line.point1.0 > line.point2.0 {
            line.point2.0..=line.point1.0
        } else {
            line.point2.1..=line.point2.0
        }
    }

    let tan: f64 = (line.point1.1 as f64 - line.point2.1 as f64)
        / (line.point1.0 as f64 - line.point2.0 as f64);
    //println!("tan: {tan}");
    let offset: f64 = line.point1.1 as f64 - tan * line.point1.0 as f64;

    for x in absolute_range(&line) {
        let y = tan * x as f64 + offset;
        let y: usize = y as usize;

        if y <= WINDOW_SIZE.1 && y >= 1 {
            insert_to_array(array, x, y, "*");
        }
    }
}

fn insert_to_array<'a>(
    array: &mut [[&'a str; WINDOW_SIZE.0]; WINDOW_SIZE.1],
    x: usize,
    y: usize,
    value: &'a str,
) {
    array[WINDOW_SIZE.1 - y][x - 1] = value;
}

fn render(array: &[[&str; WINDOW_SIZE.0]; WINDOW_SIZE.1]) {
    for row in array {
        for &elem in row {
            print!("{}", elem);
        }
        println!();
    }
}
